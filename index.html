<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bus Race Generator</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light">
  <div class="container py-5">
    <h1 class="mb-4">Bus Race Generator</h1>
    <form class="mb-3">
      <div class="mb-3">
        <label for="citiesFile" class="form-label">cities.json:</label>
        <input type="file" class="form-control" id="citiesFile" accept=".json">
      </div>
      <div class="mb-3">
        <label for="checkpoints" class="form-label">Checkpoints:</label>
        <input type="number" class="form-control" id="checkpoints" value="4" min="2" max="20">
      </div>
      <button type="button" class="btn btn-primary" id="generate">Generate Race</button>
    </form>
    <pre id="output" class="bg-white p-3 rounded border"></pre>
  </div>
  <script>
    // Haversine formula
    function haversine(a, b) {
      const toRad = x => (x * Math.PI) / 180;
      const R = 6371;
      const dLat = toRad(b.latitude - a.latitude);
      const dLon = toRad(b.longitude - a.longitude);
      const lat1 = toRad(a.latitude);
      const lat2 = toRad(b.latitude);
      const aVal =
        Math.sin(dLat / 2) ** 2 +
        Math.sin(dLon / 2) ** 2 * Math.cos(lat1) * Math.cos(lat2);
      return 2 * R * Math.asin(Math.sqrt(aVal));
    }

    // Permutations
    function permute(arr) {
      if (arr.length <= 1) return [arr];
      const result = [];
      for (let i = 0; i < arr.length; i++) {
        const rest = arr.slice(0, i).concat(arr.slice(i + 1));
        for (const p of permute(rest)) {
          result.push([arr[i]].concat(p));
        }
      }
      return result;
    }

    // Robust shuffle
    function pickRandom(arr, n) {
      if (arr.length < n) throw new Error('Not enough cities with coordinates');
      const copy = arr.slice();
      for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy.slice(0, n);
    }

    async function loadCities(fileInput) {
      if (fileInput.files[0]) {
        try {
          const text = await fileInput.files[0].text();
          return JSON.parse(text);
        } catch (e) {
          throw new Error('Invalid JSON file.');
        }
      } else {
        // Fetch local cities.json
        try {
          const resp = await fetch('cities.json');
          if (!resp.ok) throw new Error();
          return await resp.json();
        } catch (e) {
          throw new Error('Could not load local cities.json.');
        }
      }
    }

    document.getElementById('generate').onclick = async function() {
      const fileInput = document.getElementById('citiesFile');
      const checkpoints = parseInt(document.getElementById('checkpoints').value, 10) || 4;
      const output = document.getElementById('output');
      output.textContent = '';

      let cities;
      try {
        cities = await loadCities(fileInput);
      } catch (e) {
        output.textContent = e.message;
        return;
      }

      // Filter cities with latitude and longitude
      const validCities = cities.filter(
        c => typeof c.latitude === 'number' && typeof c.longitude === 'number'
      );

      let picked;
      try {
        picked = pickRandom(validCities, checkpoints);
      } catch (e) {
        output.textContent = e.message;
        return;
      }

      // Find the pair of cities with the greatest distance
      let maxDist = -Infinity, cityPair = [null, null];
      for (let i = 0; i < picked.length; i++) {
        for (let j = i + 1; j < picked.length; j++) {
          const dist = haversine(picked[i], picked[j]);
          if (dist > maxDist) {
            maxDist = dist;
            cityPair = [picked[i], picked[j]];
          }
        }
      }

      // Randomly pick one of the two as the starting city
      const startCity = cityPair[Math.floor(Math.random() * 2)];
      const startCityCount = picked.filter(c => c === startCity).length;
      const others = picked.filter(c => c !== startCity || startCityCount > 1);

      let routes = [];
      if (startCityCount > 1) {
        routes = permute(picked);
      } else {
        routes = permute(others).map(route => [startCity, ...route]);
      }

      // Find the route with the shortest total distance
      let minDist = Infinity, bestRoute = null;
      for (const route of routes) {
        let dist = 0;
        for (let i = 0; i < route.length - 1; i++) {
          dist += haversine(route[i], route[i + 1]);
        }
        if (dist < minDist) {
          minDist = dist;
          bestRoute = route;
        }
      }

      if (!bestRoute) {
        output.textContent = 'Could not find a valid route.';
        return;
      }

      output.textContent = 'Ordered cities:\n' + bestRoute.map(c => c.city).join('\n');
    };
  </script>
</body>
</html>
